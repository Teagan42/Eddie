import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";
import process from "node:process";

import knex, { type Knex } from "knex";

import { addAgentIdToToolTablesMigration } from "../src/chat-sessions/migrations/add-agent-id-to-tool-tables";
import { initialChatSessionsMigration } from "../src/chat-sessions/migrations/initial";

const DIAGRAM_OUTPUT_RELATIVE_PATH = "docs/generated/database-diagram.md";
const MERMAID_HEADER =
  "%% Auto-generated by apps/api/scripts/render-database-diagram.ts";
const MERMAID_REGENERATE =
  "%% Run `npm run docs:database-diagram` to regenerate";
const MARKDOWN_HEADER =
  "<!-- Auto-generated by apps/api/scripts/render-database-diagram.ts -->";
const MARKDOWN_REGENERATE =
  "<!-- Run `npm run docs:database-diagram` to regenerate -->";

const TABLES: readonly string[] = [
  "chat_sessions",
  "chat_session_api_keys",
  "chat_messages",
  "agent_invocations",
  "tool_calls",
  "tool_results",
];

type TableInfoRow = {
  name: string;
  type: string;
  notnull: number;
  pk: number;
};

type ForeignKeyRow = {
  table: string;
  from: string;
  to: string;
};

type DiagramColumn = {
  name: string;
  type: string;
  primaryKey: boolean;
  nullable: boolean;
};

type DiagramRelationship = {
  parentTable: string;
  parentColumn: string;
  childTable: string;
  childColumn: string;
};

function normalizePragmaResult<T>(value: unknown): T[] {
  if (Array.isArray(value)) {
    return value as T[];
  }

  if (value && typeof value === "object") {
    const rows = (value as { rows?: unknown; [key: string]: unknown }).rows;
    if (Array.isArray(rows)) {
      return rows as T[];
    }

    const first = (value as { [key: string]: unknown })[0];
    if (Array.isArray(first)) {
      return first as T[];
    }
  }

  return [];
}

function escapeIdentifier(identifier: string): string {
  return identifier.replace(/'/g, "''");
}

async function readTableInfo(db: Knex, table: string): Promise<TableInfoRow[]> {
  const escaped = escapeIdentifier(table);
  const result = await db.raw(`PRAGMA table_info('${escaped}')`);
  return normalizePragmaResult<TableInfoRow>(result);
}

async function readForeignKeys(db: Knex, table: string): Promise<ForeignKeyRow[]> {
  const escaped = escapeIdentifier(table);
  const result = await db.raw(`PRAGMA foreign_key_list('${escaped}')`);
  return normalizePragmaResult<ForeignKeyRow>(result);
}

function formatColumn(column: DiagramColumn): string {
  const parts = [`${column.type.toUpperCase()}`, column.name];

  if (column.primaryKey) {
    parts.push("PK");
  } else if (!column.nullable) {
    parts.push("NOT NULL");
  }

  return `    ${parts.join(" ")}`;
}

function formatRelationship(relationship: DiagramRelationship): string {
  return `  ${relationship.parentTable} ||--o{ ${relationship.childTable} : "${relationship.parentColumn} -> ${relationship.childColumn}"`;
}

async function buildDatabase(): Promise<Knex> {
  const db = knex({
    client: "better-sqlite3",
    connection: { filename: ":memory:" },
    useNullAsDefault: true,
  });

  await initialChatSessionsMigration(db);
  await addAgentIdToToolTablesMigration(db);

  return db;
}

async function describeTable(db: Knex, table: string): Promise<DiagramColumn[]> {
  const rows = await readTableInfo(db, table);
  return rows.map((row) => ({
    name: row.name,
    type: row.type || "",
    primaryKey: row.pk > 0,
    nullable: row.notnull === 0,
  }));
}

async function describeRelationships(db: Knex, table: string): Promise<DiagramRelationship[]> {
  const foreignKeys = await readForeignKeys(db, table);
  return foreignKeys.map((fk) => ({
    parentTable: fk.table,
    parentColumn: fk.to,
    childTable: table,
    childColumn: fk.from,
  }));
}

export async function renderDatabaseDiagramMermaid(): Promise<string> {
  const db = await buildDatabase();

  try {
    const lines: string[] = [MERMAID_HEADER, MERMAID_REGENERATE, "erDiagram"]; 

    const relationships: DiagramRelationship[] = [];

    for (const table of TABLES) {
      const columns = await describeTable(db, table);
      const columnLines = columns.map(formatColumn);

      lines.push(`  ${table} {`, ...columnLines, "  }", "");

      const tableRelationships = await describeRelationships(db, table);
      relationships.push(...tableRelationships);
    }

    if (lines[lines.length - 1] === "") {
      lines.pop();
    }

    for (const relationship of relationships) {
      lines.push(formatRelationship(relationship));
    }

    return `${lines.join("\n")}\n`;
  } finally {
    await db.destroy();
  }
}

export async function renderDatabaseDiagramMarkdown(): Promise<string> {
  const mermaid = await renderDatabaseDiagramMermaid();
  return [
    MARKDOWN_HEADER,
    MARKDOWN_REGENERATE,
    "```mermaid",
    mermaid.trimEnd(),
    "```",
    "",
  ].join("\n");
}

export async function writeDatabaseDiagramMarkdownFile(
  outputPath = resolve(process.cwd(), DIAGRAM_OUTPUT_RELATIVE_PATH),
): Promise<void> {
  const content = await renderDatabaseDiagramMarkdown();
  writeOutput(outputPath, content);
}

function writeOutput(outputPath: string, content: string): void {
  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, content);
}

function checkOutput(outputPath: string, content: string): boolean {
  if (!existsSync(outputPath)) {
    return false;
  }

  const existing = readFileSync(outputPath, "utf8");
  return existing === content;
}

async function runCli(): Promise<void> {
  const args = process.argv.slice(2);
  const check = args.includes("--check");
  const outputPath = resolve(process.cwd(), DIAGRAM_OUTPUT_RELATIVE_PATH);
  const content = await renderDatabaseDiagramMarkdown();

  if (check) {
    if (!checkOutput(outputPath, content)) {
      console.error(
        "Database diagram is out of date. Run npm run docs:database-diagram.",
      );
      process.exitCode = 1;
    }
    return;
  }

  await writeDatabaseDiagramMarkdownFile(outputPath);
}

if (require.main === module) {
  runCli().catch((error) => {
    console.error(error);
    process.exit(1);
  });
}
