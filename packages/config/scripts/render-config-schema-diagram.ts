import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";
import process from "node:process";
import type { JSONSchema7 } from "json-schema";

import {
  type EddieConfigSchemaBundle,
  EDDIE_CONFIG_SCHEMA_BUNDLE,
} from "../src/schema";

const OUTPUT_RELATIVE_PATH = "docs/generated/config-schema-diagram.md";
const MERMAID_SPECIAL_CHARS = /[<>{}:()]/;

export function renderConfigSchemaMermaid(
  bundle: EddieConfigSchemaBundle,
): string {
  const lines: string[] = [
    "%% Auto-generated by packages/config/scripts/render-config-schema-diagram.ts",
    "%% Run `npm run docs:config-schema` to regenerate",
    "graph TD",
    "  root[Eddie Configuration]",
  ];

  const rootSchema = bundle.schema;
  if (!isObjectSchema(rootSchema)) {
    return lines.join("\n");
  }

  describeObject("root", rootSchema, lines, []);

  return lines.join("\n");
}

export function renderConfigSchemaMarkdown(
  bundle: EddieConfigSchemaBundle,
): string {
  const mermaid = renderConfigSchemaMermaid(bundle);

  return [
    "<!-- Auto-generated by packages/config/scripts/render-config-schema-diagram.ts -->",
    "<!-- Run `npm run docs:config-schema` to regenerate -->",
    "```mermaid",
    mermaid,
    "```",
    "",
  ].join("\n");
}

function describeObject(
  parentId: string,
  schema: JSONSchema7,
  lines: string[],
  path: string[],
): void {
  const properties = schema.properties ?? {};
  const required = new Set(
    Array.isArray(schema.required) ? schema.required : [],
  );
  const keys = Object.keys(properties).sort();

  for (const key of keys) {
    const childSchema = properties[key] as JSONSchema7 | undefined;
    if (!childSchema) {
      continue;
    }

    const childId = sanitizeId([...path, key].join("__"));
    const nodeLabel = buildNodeLabel(key, childSchema, required.has(key));
    const mermaidLabel = formatMermaidLabel(nodeLabel);

    lines.push(`  ${parentId} --> ${childId}`);
    lines.push(`  ${childId}[${mermaidLabel}]`);

    if (isObjectSchema(childSchema)) {
      describeObject(childId, childSchema, lines, [...path, key]);
      continue;
    }

    if (isArraySchema(childSchema)) {
      const itemSchema = normalizeItems(childSchema.items);
      if (itemSchema && isObjectSchema(itemSchema)) {
        describeObject(`${childId}__item`, itemSchema, lines, [
          ...path,
          key,
          "item",
        ]);
      }
    }
  }
}

function normalizeItems(items: JSONSchema7["items"]): JSONSchema7 | undefined {
  if (!items) {
    return undefined;
  }

  if (Array.isArray(items)) {
    return items[0] as JSONSchema7 | undefined;
  }

  return items as JSONSchema7;
}

function buildNodeLabel(
  key: string,
  schema: JSONSchema7,
  isRequired: boolean,
): string {
  const displayKey = formatDisplayKey(key, isRequired);
  const summary = summarizeSchema(schema);
  return summary ? `${displayKey}: ${summary}` : displayKey;
}

function formatDisplayKey(key: string, isRequired: boolean): string {
  return isRequired ? `${key} (required)` : key;
}

function formatMermaidLabel(label: string): string {
  const needsQuotes = MERMAID_SPECIAL_CHARS.test(label);
  if (!needsQuotes && !label.includes("\"")) {
    return label;
  }

  const escaped = label.replace(/"/g, '\\"');
  return needsQuotes ? `"${escaped}"` : escaped;
}

function summarizeSchema(schema: JSONSchema7): string {
  if (Array.isArray(schema.type)) {
    return schema.type.join(" | ");
  }

  if (schema.type) {
    if (schema.type === "array") {
      const item = normalizeItems(schema.items);
      if (!item) {
        return "array";
      }

      const itemSummary = summarizeSchema(item);
      return itemSummary ? `array<${itemSummary}>` : "array";
    }

    return schema.type;
  }

  if (schema.enum) {
    return `enum(${schema.enum.length})`;
  }

  if (schema.const) {
    return `const ${schema.const}`;
  }

  if (schema.anyOf) {
    return "anyOf";
  }

  if (schema.oneOf) {
    return "oneOf";
  }

  if (schema.allOf) {
    return "allOf";
  }

  if (schema.$ref) {
    return `ref:${schema.$ref}`;
  }

  if (schema.properties) {
    return "object";
  }

  return "";
}

function sanitizeId(value: string): string {
  return value.replace(/[^a-zA-Z0-9_]/g, "_");
}

function isObjectSchema(schema: JSONSchema7 | undefined): schema is JSONSchema7 {
  if (!schema) {
    return false;
  }

  if (schema.type === "object") {
    return true;
  }

  if (Array.isArray(schema.type) && schema.type.includes("object")) {
    return true;
  }

  return Boolean(schema.properties);
}

function isArraySchema(schema: JSONSchema7 | undefined): schema is JSONSchema7 {
  if (!schema) {
    return false;
  }

  if (schema.type === "array") {
    return true;
  }

  return Array.isArray(schema.type) && schema.type.includes("array");
}

function writeMarkdown(outputPath: string, content: string): void {
  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, content);
}

function checkMarkdown(outputPath: string, content: string): boolean {
  if (!existsSync(outputPath)) {
    return false;
  }

  const existing = readFileSync(outputPath, "utf8");
  return existing === content;
}

function runCli(): void {
  const args = process.argv.slice(2);
  const check = args.includes("--check");

  const outputPath = resolve(process.cwd(), OUTPUT_RELATIVE_PATH);
  const content = renderConfigSchemaMarkdown(EDDIE_CONFIG_SCHEMA_BUNDLE);

  if (check) {
    const inSync = checkMarkdown(outputPath, content);
    if (!inSync) {
      console.error(
        "Configuration schema diagram is out of date. Run npm run docs:config-schema.",
      );
      process.exitCode = 1;
    }
    return;
  }

  writeMarkdown(outputPath, content);
}

if (require.main === module) {
  runCli();
}
